init_AUXA:
0b00011000	;Mov ACC, CTE
0b00000000	;AUXA
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC

init_Q1:
0b00011000	;Mov ACC, CTE
0b00000000	;Q1
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC

init_N:
0b00011000	;Mov ACC, CTE
0b00010000	;N
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC

While:
tst_Q0:

0b00011000	;Mov ACC, CTE
0b00000011	;Q
0b00101000 	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC	
		
0b00011000	;MOV ACC, CTE
0b00000001	;0X01
0b01000000	;AND ACC, A
0b00010000	;Mov, A, ACC
0b01011000	;JZ A hacia tst0_Q1
			
0b01010000	;JMP CTE hacia tst1_Q1
			
tst0_Q1: 
		
0b00011000	;MOV  ACC, CTE	acá vamos a mirar si el q-1 es 0 o 1	
0b00000000	;Q1					
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]

0b00010000	;Mov, A, ACC		
0b00011000	;MOV ACC, CTE
0b00000001	;0X01
0b01000000	;AND ACC, A	
0b01011000	;JZ	iguales			
0b01010000	;JMP SUM_M
			
			
tst1_Q1:		
0b00011000	;Mov ACC, CTE
0b00000000	;Q1
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC	
0b00011000	;MOV ACC, CTE
0b00000001	;0X01
0b01000000	;AND ACC, A	
0b01011000	;JZ COMPL_M
		;JMP iguales
			
			
asr_auxA:		
0b00011000	;MOV  ACC, CTE		
0b00000000	;Q1					
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC	
0b00011000	;MOV ACC, CTE
0b00000001	;0X01
0b01000000	;AND ACC, A	
0b00010000	;Mov, A, ACC	
0b00011000	;MOV  ACC, CTE	
0b00000000	;Q1					
0b00101000	;Mov DPTR, ACC
0b00110000	;MOV [DPTR], ACC 
			
COMPL_M: 	
0b00011000	;Mov ACC, CTE
0b00000101	;M
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC

0b00111000	;INV A 
0b00011000	;Mov ACC, CTE
0b00000001	;0x01
0b01001000	;ADD ACC, A 
0b00010000	;Mov, A, ACC	 
0b00011000	;Mov ACC, CTE
0b00000000	;AUXA
0b01000000	;AND ACC, A	
0b00010000	;Mov, A, ACC	 
0b00011000	;Mov ACC, CTE			
0b00000000	;AUXA											0b00101000	;Mov DPTR, ACC
0b00001000	;Mov ACC,A
0b00110000	;MOV [DPTR], ACC
0b01010000	;JMP CTE hacía iguales
 
		
SUM_M:		
0b00011000	;Mov ACC, CTE
0b00000101	;M
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC
0b00011000	;Mov ACC, CTE
0b00000000	;AUXA
0b01001000	;ADD ACC, A 
0b00010000	;Mov, A, ACC 
0b01010000	;JMP iguales 
			
	
iguales: 
0b00011000	;Mov ACC, CTE
0b00000000	;Q1	
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC
0b00011000	;Mov ACC, CTE
0b00000001	;0x01
0b01000000	;AND ACC, A
0b00010000	;Mov, A, ACC    		
0b00011000	;Mov ACC, CTE  		
0b00000000	;Q1	
0b00101000	;Mov DPTR, ACC        			
0b00110000	;MOV [DPTR], ACC

Desplazamiento aritmético a la derecha en AUXA:
0b00011000	;Mov ACC, CTE
0b00000000	;AUXA
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]
0b00010000	;Mov, A, ACC 
0b10001000	;SHR A             
0b00001000	;MOV ACC, A
0b00101000	;Mov DPTR, ACC        			
0b00110000	;MOV [DPTR], ACC
			
		
test_N:		
0b00011000	;Mov ACC, CTE
0b00000001	;0x01	
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]	 		
0b00111000	;Inv ACC
0b00010000	;Mov A, ACC
0b01001000	;ADD ACC, A 
0b00010000	;Mov A, ACC
0b00011000	;Mov ACC, CTE
0b00001000	;N
0b00101000	;Mov DPTR, ACC
0b00100000	;Mov, ACC, [DPTR]	
0b01001000	;ADD ACC, A 
0b00010000	;Mov A, ACC
0b00011000	;Mov ACC, CTE
0b00001000	;N
0b00101000	;Mov DPTR, ACC
0b00001000	;Mov[DPTR], A
0b01011000	;JZ END
0b01010000	;JMP WHILE
			

END: 		
0b11111000	;HALT


A:		00000000	; 0000 0000
AUXA:		00000000	; 0x00
M:		00000101	; 0001 0000
Q:		00000011	; 0110 0000
Q1:		00000000	; 0000 0000
N:		00001000	; 0x08
LSBA:		00000000	; 0000 0000 ; Bit menos significativo de a

Multiplicación de booth entre 5 y 3
